<!--
Library     : d3blocks
Author      : E.Taskesen
Mail        : erdogant@gmail.com
Github      : https://github.com/d3blocks/d3blocks
Licensed    : GPL3
Forked      : Mike Bostock; http://bl.ocks.org/mbostock/4063582
-->
	<!DOCTYPE html>
	<html lang="en">
	<head>
	  <meta charset="UTF-8">
	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>{{ TITLE }}</title>
      <script>
    	  {% include "d3.v6.min.js" %}
      </script>

      <script>
    	  {% include "lodash.min.js" %}
      </script>

	{{ SUPPORT }}

	</head>
	<body>

	  
	  <script>
		  const height = {{ WIDTH }};
		  const width = {{ HEIGHT }};
		  const lineHeight = 40

		pack = data => d3.pack()
			.size([width, height])
			.padding({{ borderpadding }})
		  (d3.hierarchy(data)
			.sum(d => d.value)
			.sort((a, b) => b.value - a.value))

		color = d3.scaleLinear()
			.domain([0, 5])
			.range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
			.interpolate(d3.interpolateHcl)

		function buildTree(nodes, links) {
		  // https://stackoverflow.com/a/68209716
		  const map = new Map(nodes.map((o) => [o.name, { ...o, children: [] }]));
		  for (let { source, target } of links)
			map.get(source).children.push(map.get(target));
		  return map;
		}


		// Define chart
		function createChart() {
        // Replace the data import
        const links = {{ json_data }} ;
        const node_properties = {{ json_nodes }} ;

		// Generate nodes from links
		// const nodes = _.uniq(links.flatMap((x) => [x.source, x.target])).map((name) => ({ name, value: 1 }));
		const nodes = _.uniq(links.flatMap((x) => [x.source, x.target])).map((name) => ({ name, value: Math.max(1, node_properties[name].value) })); // Use the actual value from node_properties 
		const tree = buildTree(nodes, links);
		const data = Array.from(buildTree(nodes, links).values())[0];


	function chart(data) {

	  const root = pack(data);
	  let focus = root;
	  let view;
	  let transitioning = false;
	  let delay = 1000

	  const svg = d3
		.create("svg")
		.attr("viewBox", `-${width / 2} -${height / 2} ${width} ${height}`)
		.style("display", "block")
		.style("margin", "0 -14px")
		.style("background", color(0))
		.style("cursor", "pointer")
		.on("mousemove", function (event, d) {
		  if (transitioning || event.target.tagName != "svg") return;
		  zoom(event, root);
		});

	  const node = svg
		.append("g")
		.selectAll("circle")
		.data(root.descendants().slice(1))
		.join("circle")
		.attr("fill", (d) => (d.children ? color(d.depth) : "{{ borderfill }}"))
		.attr("pointer-events", (d) => (!d.children ? "none" : null))
		.on("mouseover", function (event, d) { d3.select(this).attr("stroke", "{{ bordercolor }}").attr("stroke-width", "{{ borderwidth }}"); })
		.on("mouseout", function (event, d) { d3.select(this).attr("stroke", null).attr("stroke-width", null); })
		.on("{{ ZOOM }}", function (event, d) {
			if (transitioning || focus === d) return;
			event.stopPropagation();
			zoom(event, d);
		});

	  const textOutlineColor = "{{ fontoutlinecolor }}"; /* white outline */
	  const textOutlineRadius = 0.6; /* width of outline in pixels */
	  const label = svg
		.append("g")
		.style("font", "{{ fontsize }}px {{ fonttype }}")
		.style("fill", "{{ fontcolor }}")
		.style("text-shadow", () => {
		  const n = Math.ceil(
			2 * Math.PI * textOutlineRadius
		  ); /* number of shadows */
		  let str = "";
		  for (
			let i = 0;
			i < n;
			i++ /* append shadows in n evenly distributed directions */
		  ) {
			const theta = (2 * Math.PI * i) / n;
			str +=
			  textOutlineRadius * Math.cos(theta) +
			  "px " +
			  textOutlineRadius * Math.sin(theta) +
			  "px 0 " +
			  textOutlineColor +
			  (i == n - 1 ? "" : ",");
		  }
		  return str;
		})
		// .attr("stroke", "white")
		// .attr("stroke-width", 0.3)
		// .attr("stroke-linejoin", "round")
		.attr("pointer-events", "none")
		.attr("text-anchor", "middle")
		.selectAll("text")
		.data(root.descendants())
		.join("text")
		.attr("font-weight", 900)
		.style("fill-opacity", (d) => (d.parent === root ? 1 : 0))
		.style("display", (d) => (d.parent === root ? "inline" : "none"))
		.text((d) => d.data.name);

	  //console.log(root)
	  zoomTo([root.x, root.y, root.r * 2]);

	  function zoomTo(v) {
//	  console.log(v)
		const k = height / v[2];

		view = v;

		label.attr(
		  "transform",
		  (d) => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`
		);
		node.attr(
		  "transform",
		  (d) => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`
		);
		node.attr("r", (d) => d.r * k);
	  }

	  function zoom(event, d) {
		event.stopPropagation();
		const focus0 = focus;

		focus = d;

		const transition = svg
		  .transition()
		  .duration({{ SPEED }})
		  .tween("zoom", (d) => {
			const i = d3.interpolateZoom(view, [
			  focus.x,
			  focus.y,
			  focus.r * 2 + 15
			]);
			return (t) => zoomTo(i(t));
		  });

		label
		  .filter(function (d) {
			return d.parent === focus || this.style.display === "inline";
		  })
		  .transition(transition)
		  .style("fill-opacity", (d) => (d.parent === focus ? 1 : 0))
		  .on("start", function (d) {
			transitioning = true;
			if (d.parent === focus) {
			  this.style.display = "inline";
			}
		  })
		  .on("end", function (d) {
			// transitioning = false;
			setTimeout(() => {
			  transitioning = false;
			}, delay);
			if (d.parent !== focus) {
			  this.style.display = "none";
			}
		  });
	  }

	  return svg.node();
	}

		//	  console.log(data)
		// Call the chart function to create and append the SVG
		const svgNode = chart(data);
		// Append the generated SVG node to the body
		document.body.appendChild(svgNode);
		}

		// Call the createChart function to execute the chart creation logic
		createChart();

	  </script>
	</body>
	</html>

